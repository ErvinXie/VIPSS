//
// Created by 谢威宇 on 2020/5/12.
//

#include "OctotreeSurfacer.h"
#include <cmath>
#include <algorithm>
#include <iostream>
#include <utility>

const double EPS = 1e-6;

bool equal(double a, double b) {
    return fabs(a - b) < EPS;
}

bool ge(double a, double b) {
    return equal(a, b) || a > b;
}

bool le(double a, double b) {
    return equal(a, b) || a < b;
}

OctotreeSurfacer::OctotreeSurfacer(const vector<double> &inputPoints,
                                   const function<double(tuple<double, double, double>)> &implicitFunction,
                                   int n_voxels_1d,
                                   string out_path)
        : inputPoints(inputPoints),
          implicitFunction(implicitFunction),
          n_voxels_1d(n_voxels_1d) {
//    out = ofstream(out_path);
    for (int i = 0; i < 3; i++) {
        upper.push_back(numeric_limits<double>::min());
        lower.push_back(numeric_limits<double>::max());
    }
    for (int i = 0; i < inputPoints.size() / 3; i++) {
        for (int j = 0; j < 3; j++) {
            auto coord = inputPoints[i * 3 + j];
            upper[j] = max(upper[j], coord);
            lower[j] = min(lower[j], coord);
        }
    }
    for (int i = 0; i < 3; i++) {
        upper[i] += 0.05;
        lower[i] -= 0.05;
        step.push_back((upper[i] - lower[i]) / (double) n_voxels_1d);
//        cout<<upper[i]<<" "<<lower[i]<<" "<<step[i]<<endl;
    }

    octroot = new OctNode(this, nullptr, {0, n_voxels_1d, 0, n_voxels_1d, 0, n_voxels_1d});
    for (int i = 0; i < inputPoints.size() / 3; i++) {
        octroot->addInputPoint((inputPoints[i * 3] - lower[0]) / step[0],
                               (inputPoints[i * 3 + 1] - lower[1]) / step[1],
                               (inputPoints[i * 3 + 2] - lower[2]) / step[2]);
    }
//    octroot->debug();
}

double OctotreeSurfacer::get_function_value(tuple<int, int, int> idx) {
    if (!mem.count(idx)) {
        mem[idx] = implicitFunction(idx_to_coord(idx));
    }
    return mem[idx];
}

void OctotreeSurfacer::Surfacing() {
    mem.clear();
    octroot->Surfacing(nullptr);
    polygonize();

}

tuple<double, double, double> OctotreeSurfacer::idx_to_coord(double x, double y, double z) {
    return {lower[0] + x * step[0], lower[1] + y * step[1], lower[2] + z * step[2]};
}

tuple<double, double, double> OctotreeSurfacer::idx_to_coord(tuple<double, double, double> idx) {
    return idx_to_coord(get<0>(idx), get<1>(idx), get<2>(idx));
}


np OctotreeSurfacer::get_np_by_face(np c, int dir) {
    auto face = c->get_face(dir);
    if (face_node[dir ^ 1].count(face) == 0)
        return nullptr;
    else
        return face_node[dir ^ 1][face];
}

vector<np> OctotreeSurfacer::get_neighbors(np c) {
    vector<np> re;
    for (int i = 0; i < 6; i++) {
        re.push_back(get_np_by_face(c, i));
    }
    return re;
}

void OctotreeSurfacer::polygonize() {
    int triTable[256][16] =
            {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  1,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  8,  3,  9,  8,  1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  3,  1,  2,  10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {9,  2,  10, 0,  2,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {2,  8,  3,  2,  10, 8,  10, 9,  8,  -1, -1, -1, -1, -1, -1, -1},
             {3,  11, 2,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  11, 2,  8,  11, 0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  9,  0,  2,  3,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  11, 2,  1,  9,  11, 9,  8,  11, -1, -1, -1, -1, -1, -1, -1},
             {3,  10, 1,  11, 10, 3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  10, 1,  0,  8,  10, 8,  11, 10, -1, -1, -1, -1, -1, -1, -1},
             {3,  9,  0,  3,  11, 9,  11, 10, 9,  -1, -1, -1, -1, -1, -1, -1},
             {9,  8,  10, 10, 8,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  7,  8,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  3,  0,  7,  3,  4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  1,  9,  8,  4,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  1,  9,  4,  7,  1,  7,  3,  1,  -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  10, 8,  4,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {3,  4,  7,  3,  0,  4,  1,  2,  10, -1, -1, -1, -1, -1, -1, -1},
             {9,  2,  10, 9,  0,  2,  8,  4,  7,  -1, -1, -1, -1, -1, -1, -1},
             {2,  10, 9,  2,  9,  7,  2,  7,  3,  7,  9,  4,  -1, -1, -1, -1},
             {8,  4,  7,  3,  11, 2,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {11, 4,  7,  11, 2,  4,  2,  0,  4,  -1, -1, -1, -1, -1, -1, -1},
             {9,  0,  1,  8,  4,  7,  2,  3,  11, -1, -1, -1, -1, -1, -1, -1},
             {4,  7,  11, 9,  4,  11, 9,  11, 2,  9,  2,  1,  -1, -1, -1, -1},
             {3,  10, 1,  3,  11, 10, 7,  8,  4,  -1, -1, -1, -1, -1, -1, -1},
             {1,  11, 10, 1,  4,  11, 1,  0,  4,  7,  11, 4,  -1, -1, -1, -1},
             {4,  7,  8,  9,  0,  11, 9,  11, 10, 11, 0,  3,  -1, -1, -1, -1},
             {4,  7,  11, 4,  11, 9,  9,  11, 10, -1, -1, -1, -1, -1, -1, -1},
             {9,  5,  4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {9,  5,  4,  0,  8,  3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  5,  4,  1,  5,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {8,  5,  4,  8,  3,  5,  3,  1,  5,  -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  10, 9,  5,  4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {3,  0,  8,  1,  2,  10, 4,  9,  5,  -1, -1, -1, -1, -1, -1, -1},
             {5,  2,  10, 5,  4,  2,  4,  0,  2,  -1, -1, -1, -1, -1, -1, -1},
             {2,  10, 5,  3,  2,  5,  3,  5,  4,  3,  4,  8,  -1, -1, -1, -1},
             {9,  5,  4,  2,  3,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  11, 2,  0,  8,  11, 4,  9,  5,  -1, -1, -1, -1, -1, -1, -1},
             {0,  5,  4,  0,  1,  5,  2,  3,  11, -1, -1, -1, -1, -1, -1, -1},
             {2,  1,  5,  2,  5,  8,  2,  8,  11, 4,  8,  5,  -1, -1, -1, -1},
             {10, 3,  11, 10, 1,  3,  9,  5,  4,  -1, -1, -1, -1, -1, -1, -1},
             {4,  9,  5,  0,  8,  1,  8,  10, 1,  8,  11, 10, -1, -1, -1, -1},
             {5,  4,  0,  5,  0,  11, 5,  11, 10, 11, 0,  3,  -1, -1, -1, -1},
             {5,  4,  8,  5,  8,  10, 10, 8,  11, -1, -1, -1, -1, -1, -1, -1},
             {9,  7,  8,  5,  7,  9,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {9,  3,  0,  9,  5,  3,  5,  7,  3,  -1, -1, -1, -1, -1, -1, -1},
             {0,  7,  8,  0,  1,  7,  1,  5,  7,  -1, -1, -1, -1, -1, -1, -1},
             {1,  5,  3,  3,  5,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {9,  7,  8,  9,  5,  7,  10, 1,  2,  -1, -1, -1, -1, -1, -1, -1},
             {10, 1,  2,  9,  5,  0,  5,  3,  0,  5,  7,  3,  -1, -1, -1, -1},
             {8,  0,  2,  8,  2,  5,  8,  5,  7,  10, 5,  2,  -1, -1, -1, -1},
             {2,  10, 5,  2,  5,  3,  3,  5,  7,  -1, -1, -1, -1, -1, -1, -1},
             {7,  9,  5,  7,  8,  9,  3,  11, 2,  -1, -1, -1, -1, -1, -1, -1},
             {9,  5,  7,  9,  7,  2,  9,  2,  0,  2,  7,  11, -1, -1, -1, -1},
             {2,  3,  11, 0,  1,  8,  1,  7,  8,  1,  5,  7,  -1, -1, -1, -1},
             {11, 2,  1,  11, 1,  7,  7,  1,  5,  -1, -1, -1, -1, -1, -1, -1},
             {9,  5,  8,  8,  5,  7,  10, 1,  3,  10, 3,  11, -1, -1, -1, -1},
             {5,  7,  0,  5,  0,  9,  7,  11, 0,  1,  0,  10, 11, 10, 0,  -1},
             {11, 10, 0,  11, 0,  3,  10, 5,  0,  8,  0,  7,  5,  7,  0,  -1},
             {11, 10, 5,  7,  11, 5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {10, 6,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  3,  5,  10, 6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {9,  0,  1,  5,  10, 6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  8,  3,  1,  9,  8,  5,  10, 6,  -1, -1, -1, -1, -1, -1, -1},
             {1,  6,  5,  2,  6,  1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  6,  5,  1,  2,  6,  3,  0,  8,  -1, -1, -1, -1, -1, -1, -1},
             {9,  6,  5,  9,  0,  6,  0,  2,  6,  -1, -1, -1, -1, -1, -1, -1},
             {5,  9,  8,  5,  8,  2,  5,  2,  6,  3,  2,  8,  -1, -1, -1, -1},
             {2,  3,  11, 10, 6,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {11, 0,  8,  11, 2,  0,  10, 6,  5,  -1, -1, -1, -1, -1, -1, -1},
             {0,  1,  9,  2,  3,  11, 5,  10, 6,  -1, -1, -1, -1, -1, -1, -1},
             {5,  10, 6,  1,  9,  2,  9,  11, 2,  9,  8,  11, -1, -1, -1, -1},
             {6,  3,  11, 6,  5,  3,  5,  1,  3,  -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  11, 0,  11, 5,  0,  5,  1,  5,  11, 6,  -1, -1, -1, -1},
             {3,  11, 6,  0,  3,  6,  0,  6,  5,  0,  5,  9,  -1, -1, -1, -1},
             {6,  5,  9,  6,  9,  11, 11, 9,  8,  -1, -1, -1, -1, -1, -1, -1},
             {5,  10, 6,  4,  7,  8,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  3,  0,  4,  7,  3,  6,  5,  10, -1, -1, -1, -1, -1, -1, -1},
             {1,  9,  0,  5,  10, 6,  8,  4,  7,  -1, -1, -1, -1, -1, -1, -1},
             {10, 6,  5,  1,  9,  7,  1,  7,  3,  7,  9,  4,  -1, -1, -1, -1},
             {6,  1,  2,  6,  5,  1,  4,  7,  8,  -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  5,  5,  2,  6,  3,  0,  4,  3,  4,  7,  -1, -1, -1, -1},
             {8,  4,  7,  9,  0,  5,  0,  6,  5,  0,  2,  6,  -1, -1, -1, -1},
             {7,  3,  9,  7,  9,  4,  3,  2,  9,  5,  9,  6,  2,  6,  9,  -1},
             {3,  11, 2,  7,  8,  4,  10, 6,  5,  -1, -1, -1, -1, -1, -1, -1},
             {5,  10, 6,  4,  7,  2,  4,  2,  0,  2,  7,  11, -1, -1, -1, -1},
             {0,  1,  9,  4,  7,  8,  2,  3,  11, 5,  10, 6,  -1, -1, -1, -1},
             {9,  2,  1,  9,  11, 2,  9,  4,  11, 7,  11, 4,  5,  10, 6,  -1},
             {8,  4,  7,  3,  11, 5,  3,  5,  1,  5,  11, 6,  -1, -1, -1, -1},
             {5,  1,  11, 5,  11, 6,  1,  0,  11, 7,  11, 4,  0,  4,  11, -1},
             {0,  5,  9,  0,  6,  5,  0,  3,  6,  11, 6,  3,  8,  4,  7,  -1},
             {6,  5,  9,  6,  9,  11, 4,  7,  9,  7,  11, 9,  -1, -1, -1, -1},
             {10, 4,  9,  6,  4,  10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  10, 6,  4,  9,  10, 0,  8,  3,  -1, -1, -1, -1, -1, -1, -1},
             {10, 0,  1,  10, 6,  0,  6,  4,  0,  -1, -1, -1, -1, -1, -1, -1},
             {8,  3,  1,  8,  1,  6,  8,  6,  4,  6,  1,  10, -1, -1, -1, -1},
             {1,  4,  9,  1,  2,  4,  2,  6,  4,  -1, -1, -1, -1, -1, -1, -1},
             {3,  0,  8,  1,  2,  9,  2,  4,  9,  2,  6,  4,  -1, -1, -1, -1},
             {0,  2,  4,  4,  2,  6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {8,  3,  2,  8,  2,  4,  4,  2,  6,  -1, -1, -1, -1, -1, -1, -1},
             {10, 4,  9,  10, 6,  4,  11, 2,  3,  -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  2,  2,  8,  11, 4,  9,  10, 4,  10, 6,  -1, -1, -1, -1},
             {3,  11, 2,  0,  1,  6,  0,  6,  4,  6,  1,  10, -1, -1, -1, -1},
             {6,  4,  1,  6,  1,  10, 4,  8,  1,  2,  1,  11, 8,  11, 1,  -1},
             {9,  6,  4,  9,  3,  6,  9,  1,  3,  11, 6,  3,  -1, -1, -1, -1},
             {8,  11, 1,  8,  1,  0,  11, 6,  1,  9,  1,  4,  6,  4,  1,  -1},
             {3,  11, 6,  3,  6,  0,  0,  6,  4,  -1, -1, -1, -1, -1, -1, -1},
             {6,  4,  8,  11, 6,  8,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {7,  10, 6,  7,  8,  10, 8,  9,  10, -1, -1, -1, -1, -1, -1, -1},
             {0,  7,  3,  0,  10, 7,  0,  9,  10, 6,  7,  10, -1, -1, -1, -1},
             {10, 6,  7,  1,  10, 7,  1,  7,  8,  1,  8,  0,  -1, -1, -1, -1},
             {10, 6,  7,  10, 7,  1,  1,  7,  3,  -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  6,  1,  6,  8,  1,  8,  9,  8,  6,  7,  -1, -1, -1, -1},
             {2,  6,  9,  2,  9,  1,  6,  7,  9,  0,  9,  3,  7,  3,  9,  -1},
             {7,  8,  0,  7,  0,  6,  6,  0,  2,  -1, -1, -1, -1, -1, -1, -1},
             {7,  3,  2,  6,  7,  2,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {2,  3,  11, 10, 6,  8,  10, 8,  9,  8,  6,  7,  -1, -1, -1, -1},
             {2,  0,  7,  2,  7,  11, 0,  9,  7,  6,  7,  10, 9,  10, 7,  -1},
             {1,  8,  0,  1,  7,  8,  1,  10, 7,  6,  7,  10, 2,  3,  11, -1},
             {11, 2,  1,  11, 1,  7,  10, 6,  1,  6,  7,  1,  -1, -1, -1, -1},
             {8,  9,  6,  8,  6,  7,  9,  1,  6,  11, 6,  3,  1,  3,  6,  -1},
             {0,  9,  1,  11, 6,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {7,  8,  0,  7,  0,  6,  3,  11, 0,  11, 6,  0,  -1, -1, -1, -1},
             {7,  11, 6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {7,  6,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {3,  0,  8,  11, 7,  6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  1,  9,  11, 7,  6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {8,  1,  9,  8,  3,  1,  11, 7,  6,  -1, -1, -1, -1, -1, -1, -1},
             {10, 1,  2,  6,  11, 7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  10, 3,  0,  8,  6,  11, 7,  -1, -1, -1, -1, -1, -1, -1},
             {2,  9,  0,  2,  10, 9,  6,  11, 7,  -1, -1, -1, -1, -1, -1, -1},
             {6,  11, 7,  2,  10, 3,  10, 8,  3,  10, 9,  8,  -1, -1, -1, -1},
             {7,  2,  3,  6,  2,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {7,  0,  8,  7,  6,  0,  6,  2,  0,  -1, -1, -1, -1, -1, -1, -1},
             {2,  7,  6,  2,  3,  7,  0,  1,  9,  -1, -1, -1, -1, -1, -1, -1},
             {1,  6,  2,  1,  8,  6,  1,  9,  8,  8,  7,  6,  -1, -1, -1, -1},
             {10, 7,  6,  10, 1,  7,  1,  3,  7,  -1, -1, -1, -1, -1, -1, -1},
             {10, 7,  6,  1,  7,  10, 1,  8,  7,  1,  0,  8,  -1, -1, -1, -1},
             {0,  3,  7,  0,  7,  10, 0,  10, 9,  6,  10, 7,  -1, -1, -1, -1},
             {7,  6,  10, 7,  10, 8,  8,  10, 9,  -1, -1, -1, -1, -1, -1, -1},
             {6,  8,  4,  11, 8,  6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {3,  6,  11, 3,  0,  6,  0,  4,  6,  -1, -1, -1, -1, -1, -1, -1},
             {8,  6,  11, 8,  4,  6,  9,  0,  1,  -1, -1, -1, -1, -1, -1, -1},
             {9,  4,  6,  9,  6,  3,  9,  3,  1,  11, 3,  6,  -1, -1, -1, -1},
             {6,  8,  4,  6,  11, 8,  2,  10, 1,  -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  10, 3,  0,  11, 0,  6,  11, 0,  4,  6,  -1, -1, -1, -1},
             {4,  11, 8,  4,  6,  11, 0,  2,  9,  2,  10, 9,  -1, -1, -1, -1},
             {10, 9,  3,  10, 3,  2,  9,  4,  3,  11, 3,  6,  4,  6,  3,  -1},
             {8,  2,  3,  8,  4,  2,  4,  6,  2,  -1, -1, -1, -1, -1, -1, -1},
             {0,  4,  2,  4,  6,  2,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  9,  0,  2,  3,  4,  2,  4,  6,  4,  3,  8,  -1, -1, -1, -1},
             {1,  9,  4,  1,  4,  2,  2,  4,  6,  -1, -1, -1, -1, -1, -1, -1},
             {8,  1,  3,  8,  6,  1,  8,  4,  6,  6,  10, 1,  -1, -1, -1, -1},
             {10, 1,  0,  10, 0,  6,  6,  0,  4,  -1, -1, -1, -1, -1, -1, -1},
             {4,  6,  3,  4,  3,  8,  6,  10, 3,  0,  3,  9,  10, 9,  3,  -1},
             {10, 9,  4,  6,  10, 4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  9,  5,  7,  6,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  3,  4,  9,  5,  11, 7,  6,  -1, -1, -1, -1, -1, -1, -1},
             {5,  0,  1,  5,  4,  0,  7,  6,  11, -1, -1, -1, -1, -1, -1, -1},
             {11, 7,  6,  8,  3,  4,  3,  5,  4,  3,  1,  5,  -1, -1, -1, -1},
             {9,  5,  4,  10, 1,  2,  7,  6,  11, -1, -1, -1, -1, -1, -1, -1},
             {6,  11, 7,  1,  2,  10, 0,  8,  3,  4,  9,  5,  -1, -1, -1, -1},
             {7,  6,  11, 5,  4,  10, 4,  2,  10, 4,  0,  2,  -1, -1, -1, -1},
             {3,  4,  8,  3,  5,  4,  3,  2,  5,  10, 5,  2,  11, 7,  6,  -1},
             {7,  2,  3,  7,  6,  2,  5,  4,  9,  -1, -1, -1, -1, -1, -1, -1},
             {9,  5,  4,  0,  8,  6,  0,  6,  2,  6,  8,  7,  -1, -1, -1, -1},
             {3,  6,  2,  3,  7,  6,  1,  5,  0,  5,  4,  0,  -1, -1, -1, -1},
             {6,  2,  8,  6,  8,  7,  2,  1,  8,  4,  8,  5,  1,  5,  8,  -1},
             {9,  5,  4,  10, 1,  6,  1,  7,  6,  1,  3,  7,  -1, -1, -1, -1},
             {1,  6,  10, 1,  7,  6,  1,  0,  7,  8,  7,  0,  9,  5,  4,  -1},
             {4,  0,  10, 4,  10, 5,  0,  3,  10, 6,  10, 7,  3,  7,  10, -1},
             {7,  6,  10, 7,  10, 8,  5,  4,  10, 4,  8,  10, -1, -1, -1, -1},
             {6,  9,  5,  6,  11, 9,  11, 8,  9,  -1, -1, -1, -1, -1, -1, -1},
             {3,  6,  11, 0,  6,  3,  0,  5,  6,  0,  9,  5,  -1, -1, -1, -1},
             {0,  11, 8,  0,  5,  11, 0,  1,  5,  5,  6,  11, -1, -1, -1, -1},
             {6,  11, 3,  6,  3,  5,  5,  3,  1,  -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  10, 9,  5,  11, 9,  11, 8,  11, 5,  6,  -1, -1, -1, -1},
             {0,  11, 3,  0,  6,  11, 0,  9,  6,  5,  6,  9,  1,  2,  10, -1},
             {11, 8,  5,  11, 5,  6,  8,  0,  5,  10, 5,  2,  0,  2,  5,  -1},
             {6,  11, 3,  6,  3,  5,  2,  10, 3,  10, 5,  3,  -1, -1, -1, -1},
             {5,  8,  9,  5,  2,  8,  5,  6,  2,  3,  8,  2,  -1, -1, -1, -1},
             {9,  5,  6,  9,  6,  0,  0,  6,  2,  -1, -1, -1, -1, -1, -1, -1},
             {1,  5,  8,  1,  8,  0,  5,  6,  8,  3,  8,  2,  6,  2,  8,  -1},
             {1,  5,  6,  2,  1,  6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  3,  6,  1,  6,  10, 3,  8,  6,  5,  6,  9,  8,  9,  6,  -1},
             {10, 1,  0,  10, 0,  6,  9,  5,  0,  5,  6,  0,  -1, -1, -1, -1},
             {0,  3,  8,  5,  6,  10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {10, 5,  6,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {11, 5,  10, 7,  5,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {11, 5,  10, 11, 7,  5,  8,  3,  0,  -1, -1, -1, -1, -1, -1, -1},
             {5,  11, 7,  5,  10, 11, 1,  9,  0,  -1, -1, -1, -1, -1, -1, -1},
             {10, 7,  5,  10, 11, 7,  9,  8,  1,  8,  3,  1,  -1, -1, -1, -1},
             {11, 1,  2,  11, 7,  1,  7,  5,  1,  -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  3,  1,  2,  7,  1,  7,  5,  7,  2,  11, -1, -1, -1, -1},
             {9,  7,  5,  9,  2,  7,  9,  0,  2,  2,  11, 7,  -1, -1, -1, -1},
             {7,  5,  2,  7,  2,  11, 5,  9,  2,  3,  2,  8,  9,  8,  2,  -1},
             {2,  5,  10, 2,  3,  5,  3,  7,  5,  -1, -1, -1, -1, -1, -1, -1},
             {8,  2,  0,  8,  5,  2,  8,  7,  5,  10, 2,  5,  -1, -1, -1, -1},
             {9,  0,  1,  5,  10, 3,  5,  3,  7,  3,  10, 2,  -1, -1, -1, -1},
             {9,  8,  2,  9,  2,  1,  8,  7,  2,  10, 2,  5,  7,  5,  2,  -1},
             {1,  3,  5,  3,  7,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  7,  0,  7,  1,  1,  7,  5,  -1, -1, -1, -1, -1, -1, -1},
             {9,  0,  3,  9,  3,  5,  5,  3,  7,  -1, -1, -1, -1, -1, -1, -1},
             {9,  8,  7,  5,  9,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {5,  8,  4,  5,  10, 8,  10, 11, 8,  -1, -1, -1, -1, -1, -1, -1},
             {5,  0,  4,  5,  11, 0,  5,  10, 11, 11, 3,  0,  -1, -1, -1, -1},
             {0,  1,  9,  8,  4,  10, 8,  10, 11, 10, 4,  5,  -1, -1, -1, -1},
             {10, 11, 4,  10, 4,  5,  11, 3,  4,  9,  4,  1,  3,  1,  4,  -1},
             {2,  5,  1,  2,  8,  5,  2,  11, 8,  4,  5,  8,  -1, -1, -1, -1},
             {0,  4,  11, 0,  11, 3,  4,  5,  11, 2,  11, 1,  5,  1,  11, -1},
             {0,  2,  5,  0,  5,  9,  2,  11, 5,  4,  5,  8,  11, 8,  5,  -1},
             {9,  4,  5,  2,  11, 3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {2,  5,  10, 3,  5,  2,  3,  4,  5,  3,  8,  4,  -1, -1, -1, -1},
             {5,  10, 2,  5,  2,  4,  4,  2,  0,  -1, -1, -1, -1, -1, -1, -1},
             {3,  10, 2,  3,  5,  10, 3,  8,  5,  4,  5,  8,  0,  1,  9,  -1},
             {5,  10, 2,  5,  2,  4,  1,  9,  2,  9,  4,  2,  -1, -1, -1, -1},
             {8,  4,  5,  8,  5,  3,  3,  5,  1,  -1, -1, -1, -1, -1, -1, -1},
             {0,  4,  5,  1,  0,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {8,  4,  5,  8,  5,  3,  9,  0,  5,  0,  3,  5,  -1, -1, -1, -1},
             {9,  4,  5,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  11, 7,  4,  9,  11, 9,  10, 11, -1, -1, -1, -1, -1, -1, -1},
             {0,  8,  3,  4,  9,  7,  9,  11, 7,  9,  10, 11, -1, -1, -1, -1},
             {1,  10, 11, 1,  11, 4,  1,  4,  0,  7,  4,  11, -1, -1, -1, -1},
             {3,  1,  4,  3,  4,  8,  1,  10, 4,  7,  4,  11, 10, 11, 4,  -1},
             {4,  11, 7,  9,  11, 4,  9,  2,  11, 9,  1,  2,  -1, -1, -1, -1},
             {9,  7,  4,  9,  11, 7,  9,  1,  11, 2,  11, 1,  0,  8,  3,  -1},
             {11, 7,  4,  11, 4,  2,  2,  4,  0,  -1, -1, -1, -1, -1, -1, -1},
             {11, 7,  4,  11, 4,  2,  8,  3,  4,  3,  2,  4,  -1, -1, -1, -1},
             {2,  9,  10, 2,  7,  9,  2,  3,  7,  7,  4,  9,  -1, -1, -1, -1},
             {9,  10, 7,  9,  7,  4,  10, 2,  7,  8,  7,  0,  2,  0,  7,  -1},
             {3,  7,  10, 3,  10, 2,  7,  4,  10, 1,  10, 0,  4,  0,  10, -1},
             {1,  10, 2,  8,  7,  4,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  9,  1,  4,  1,  7,  7,  1,  3,  -1, -1, -1, -1, -1, -1, -1},
             {4,  9,  1,  4,  1,  7,  0,  8,  1,  8,  7,  1,  -1, -1, -1, -1},
             {4,  0,  3,  7,  4,  3,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {4,  8,  7,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {9,  10, 8,  10, 11, 8,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {3,  0,  9,  3,  9,  11, 11, 9,  10, -1, -1, -1, -1, -1, -1, -1},
             {0,  1,  10, 0,  10, 8,  8,  10, 11, -1, -1, -1, -1, -1, -1, -1},
             {3,  1,  10, 11, 3,  10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  2,  11, 1,  11, 9,  9,  11, 8,  -1, -1, -1, -1, -1, -1, -1},
             {3,  0,  9,  3,  9,  11, 1,  2,  9,  2,  11, 9,  -1, -1, -1, -1},
             {0,  2,  11, 8,  0,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {3,  2,  11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {2,  3,  8,  2,  8,  10, 10, 8,  9,  -1, -1, -1, -1, -1, -1, -1},
             {9,  10, 2,  0,  9,  2,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {2,  3,  8,  2,  8,  10, 0,  1,  8,  1,  10, 8,  -1, -1, -1, -1},
             {1,  10, 2,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {1,  3,  8,  9,  1,  8,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  9,  1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {0,  3,  8,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
             {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};
    int edge[12][2] = {
            {0, 1},
            {1, 2},
            {2, 3},
            {0, 3},
            {4, 5},
            {5, 6},
            {6, 7},
            {4, 7},
            {0, 4},
            {1, 5},
            {2, 6},
            {3, 7},
    };

    for (auto c:cubes) {
//        c->debug();
//        cout << "get_mc_idx" << endl;
        auto idx = c->get_mc_idx();
//        cout << "push tri" << endl;
        for (int i = 0; i < 16; i++) {
//            cout << i << endl;
            if (triTable[idx][i] == -1)
                break;
            auto e = triTable[idx][i];
            triangleFaces.push_back(get_interpolant_point(c->mc_point[edge[e][0]], c->mc_point[edge[e][1]]));
        }
    }
}

int OctotreeSurfacer::get_interpolant_point(vector<int> v, vector<int> u) {
    v.insert(v.end(), u.begin(), u.end());
    if (!interpolant_point.count(v)) {
        auto a = abs(get_function_value({v[0], v[1], v[2]})), b = abs(get_function_value({v[3], v[4], v[5]}));
        vector<double> p = {0, 0, 0};
        for (int i = 0; i < 3; i++) {
            if (v[i] == v[i + 3]) {
                p[i] = v[i];
            } else {
                p[i] = (v[i] * b + v[i + 3] * a) / (a + b);
            }
        }
        auto x = idx_to_coord(p[0], p[1], p[2]);
        vertices.push_back(get<0>(x));
        vertices.push_back(get<1>(x));
        vertices.push_back(get<2>(x));
        interpolant_point[v] = vertices.size() / 3 - 1;
    }
    return interpolant_point[v];
}


OctNode::OctNode(OctotreeSurfacer *surfacer, np father, const vector<int> &range) :
        surfacer(surfacer),
        father(father),
        range(range) {
    containInput = false;
    visited = false;
    split = false;

    point_seg = {{range[0], range[1]},
                 {range[2], range[3]},
                 {range[4], range[5]}};
    corner = point_seg;
    end = true;
    for (auto &p:point_seg) {
        auto dp = p[1] - p[0];
        if (dp > 1) {
//            if (dp % 2 == 1) {
//                p.insert(p.begin() + 1, p[0] + dp / 2 + 1);
//            }
            p.insert(p.begin() + 1, p[0] + dp / 2);
            end = false;
        }
    }

    if (!end) {
        for (int i = 0; i < point_seg[0].size() - 1; i++) {
            for (int j = 0; j < point_seg[1].size() - 1; j++) {
                for (int k = 0; k < point_seg[2].size() - 1; k++) {
                    sons.push_back(nullptr);
                }
            }
        }
    }
    for (int i = 0; i < 6; i++) {
        surfacer->face_node[i][get_face(i)] = this;
    }
    for (int i = 0; i < 8; i++) {
        corner_signs.push_back(0);
    }
    int d = 0;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 2; k++) {
                auto v = surfacer->get_function_value({corner[0][i], corner[1][j], corner[2][k]});
                if (equal(v, 0)) {
                    corner_signs[d] |= 3;
                } else if (v < 0) {
                    corner_signs[d] |= 2;
                } else if (v > 0) {
                    corner_signs[d] |= 1;
                }
                d++;
            }
        }
    }

    for (int i = 0; i < 6; i++)
        face_signs.push_back(0);

    int idx[6][4] = {{4, 5, 6, 7},
                     {0, 1, 2, 3},
                     {2, 3, 6, 7},
                     {0, 1, 4, 5},
                     {1, 3, 5, 7},
                     {0, 2, 4, 6}};
    for (int i = 0; i < 6; i++)
        for (int j = 0; j < 4; j++)
            face_signs[i] |= corner_signs[idx[i][j]];

    mc_point = {
            {corner[0][0], corner[1][0], corner[2][0]},
            {corner[0][0], corner[1][0], corner[2][1]},
            {corner[0][0], corner[1][1], corner[2][1]},
            {corner[0][0], corner[1][1], corner[2][0]},
            {corner[0][1], corner[1][0], corner[2][0]},
            {corner[0][1], corner[1][0], corner[2][1]},
            {corner[0][1], corner[1][1], corner[2][1]},
            {corner[0][1], corner[1][1], corner[2][0]}
    };

}

int OctNode::get_son_idx(double ix, double iy, double iz) {
    int d = 0;
    for (int i = 0; i < point_seg[0].size() - 1; i++) {
        for (int j = 0; j < point_seg[1].size() - 1; j++) {
            for (int k = 0; k < point_seg[2].size() - 1; k++) {
                if (ix >= i && iy >= j && iz >= k) {
                    return d;
                }
                d++;
            }
        }
    }
    return -1;
}

np &OctNode::get_son(double ix, double iy, double iz) {
    return sons[get_son_idx(ix, iy, iz)];
}

void OctNode::addInputPoint(double ix, double iy, double iz) {
    containInput = true;
    if (!end) {
        int d = 0;
        for (int i = 0; i < point_seg[0].size() - 1; i++) {
            for (int j = 0; j < point_seg[1].size() - 1; j++) {
                for (int k = 0; k < point_seg[2].size() - 1; k++) {
                    if (ge(ix, point_seg[0][i]) && ge(iy, point_seg[1][j]) && ge(iz, point_seg[2][k])
                        && le(ix, point_seg[0][i + 1]) && le(iy, point_seg[1][j + 1]) && le(iz, point_seg[2][k + 1])) {
                        if (sons[d] == nullptr) {
                            sons[d] = new OctNode(surfacer, this, {point_seg[0][i], point_seg[0][i + 1],
                                                                   point_seg[1][j], point_seg[1][j + 1],
                                                                   point_seg[2][k], point_seg[2][k + 1]});
                        }
                        sons[d]->addInputPoint(ix, iy, iz);
                    }
                    d++;
                }
            }
        }
    }
}

void OctNode::debug(int d) {
    string indent;
    for (int i = 0; i < d; i++)
        indent += "  ";
    cout << indent;
    for (auto b:range) {
        cout << b << " ";
    }
    cout << endl;
    for (auto p:sons) {
        if (p != nullptr) {
            p->debug(d + 1);
        }
    }
}


void OctNode::Surfacing(np caller) {
    if (split)
        return;

    visited = true;
    bool intersect_with_surface = intersect();

//    for (int i = 0; i < 6; i++) {
//        cout << range[i] << " ";
//        if (i & 1) {
//            cout << "|\t";
//        }
//    }
//    cout << "input: " << containInput << " intersect: " << intersect_with_surface << endl;

    if (containInput || intersect_with_surface) {
        if (!end) {
            split = true;

            int d = 0;
            for (int i = 0; i < point_seg[0].size() - 1; i++) {
                for (int j = 0; j < point_seg[1].size() - 1; j++) {
                    for (int k = 0; k < point_seg[2].size() - 1; k++) {
                        if (sons[d] == nullptr) {
                            sons[d] = new OctNode(
                                    surfacer, this,
                                    {point_seg[0][i], point_seg[0][i + 1], point_seg[1][j], point_seg[1][j + 1],
                                     point_seg[2][k], point_seg[2][k + 1]});
                        }
                        d++;
                    }
                }
            }

//            bool splited = true;
//            while (splited) {
//                splited = false;
//                for (auto s:sons) {
//                    if (!s->split) {
//                        s->Surfacing(this);
//                        splited = s->split;
//                    }
//                }
//            }
            for (auto s:sons) {
                s->Surfacing(this);
            }


            d = 0;
            for (int i = 0; i < point_seg[0].size() - 1; i++) {
                for (int j = 0; j < point_seg[1].size() - 1; j++) {
                    for (int k = 0; k < point_seg[2].size() - 1; k++) {
                        if (i == 0) {
                            face_signs[1] |= sons[d]->get_signs(false)[1];
                        }
                        if (i == point_seg[0].size() - 2) {
                            face_signs[0] |= sons[d]->get_signs(false)[0];
                        }
                        if (j == 0) {
                            face_signs[3] |= sons[d]->get_signs(false)[3];
                        }
                        if (j == point_seg[1].size() - 2) {
                            face_signs[2] |= sons[d]->get_signs(false)[2];
                        }
                        if (k == 0) {
                            face_signs[5] |= sons[d]->get_signs(false)[5];
                        }
                        if (k == point_seg[2].size() - 2) {
                            face_signs[4] |= sons[d]->get_signs(false)[4];
                        }
                        d++;
                    }
                }
            }

            if (caller != father) {
                father->update_sign(this);
            }
//            auto neighbors = surfacer->get_neighbors(this);
//            for (int i = 0; i < 6; i++) {
//                if (neighbors[i] != nullptr) {
//                    neighbors[i]->get_signs(false);
//                    neighbors[i]->signs[i ^ 1] |= signs[i];
//                }
//            }

            for (auto n:surfacer->get_neighbors(this)) {
                if (n != nullptr && n->visited && n->split == false) {
//                    for (int i = 0; i < 6; i++) {
//                        cout << range[i] << " ";
//                        if (i & 1) {
//                            cout << "|\t";
//                        }
//                    }
//                    cout << end << " jump " << n->end << endl;
                    n->Surfacing(this);
                }
            }


        } else {
            if (intersect_with_surface == true) {
//                cout << "*" << endl;
                surfacer->cubes.push_back(this);
//                for (int i = 0; i < 3; i++) {
//                    surfacer->out << surfacer->lower[i] + (point_seg[i][0] + point_seg[i][1]) / 2. * surfacer->step[i]
//                                  << " ";
//                }
//                surfacer->out << endl;
            }
        }
    }
//    else {
//        if (containInput == true) {
//            for (auto x:range) {
//                cout << x << " ";
//            }
//            cout << endl;
//        }
//    }
}

tuple<int, int, int, int, int> OctNode::get_face(int dir) {
    if (dir == 0) {
        return {range[1], range[2], range[3], range[4], range[5]};
    } else if (dir == 1) {
        return {range[0], range[2], range[3], range[4], range[5]};
    } else if (dir == 2) {
        return {range[3], range[0], range[1], range[4], range[5]};
    } else if (dir == 3) {
        return {range[2], range[0], range[1], range[4], range[5]};
    } else if (dir == 4) {
        return {range[5], range[0], range[1], range[2], range[3]};
    } else if (dir == 5) {
        return {range[4], range[0], range[1], range[2], range[3]};
    }
}

template<typename first_type, typename tuple_type, size_t ...index>
auto to_vector_helper(const tuple_type &t, std::index_sequence<index...>) {
    return std::vector<first_type>{
            std::get<index>(t)...
    };
}

template<typename first_type, typename ...others>
auto to_vector(const std::tuple<first_type, others...> &t) {
    typedef typename std::remove_reference<decltype(t)>::type tuple_type;
    constexpr auto s = std::tuple_size<tuple_type>::value;
    return to_vector_helper<first_type, tuple_type>(t, std::make_index_sequence<s>{});
}

vector<int> OctNode::get_signs(bool prevent) {
    if (prevent == false) {
        for (int i = 0; i < 6; i++) {
            auto neighbor = surfacer->get_np_by_face(this, i);
            if (neighbor != nullptr && neighbor->split) {
                face_signs[i] |= neighbor->get_signs(true)[i ^ 1];
            }
        }
    }
    return face_signs;
}

bool OctNode::intersect() {
    int re = 0;
    for (auto s:get_signs(false)) {
        re |= s;
    }
    return re == 3;
}


void OctNode::update_sign(np sonp) {
    int d = 0;
    for (int i = 0; i < point_seg[0].size() - 1; i++) {
        for (int j = 0; j < point_seg[1].size() - 1; j++) {
            for (int k = 0; k < point_seg[2].size() - 1; k++) {
                if (sons[d] == sonp) {
                    if (i == 0) {
                        face_signs[1] |= sons[d]->get_signs(false)[1];
                    }
                    if (i == point_seg[0].size() - 2) {
                        face_signs[0] |= sons[d]->get_signs(false)[0];
                    }
                    if (j == 0) {
                        face_signs[3] |= sons[d]->get_signs(false)[3];
                    }
                    if (j == point_seg[1].size() - 2) {
                        face_signs[2] |= sons[d]->get_signs(false)[2];
                    }
                    if (k == 0) {
                        face_signs[5] |= sons[d]->get_signs(false)[5];
                    }
                    if (k == point_seg[2].size() - 2) {
                        face_signs[4] |= sons[d]->get_signs(false)[4];
                    }
                    if (father != nullptr) {
                        father->update_sign(this);
                    }
                    return;
                }
                d++;
            }
        }
    }
}

void OctNode::update_surround_signs() {
    auto neighbors = surfacer->get_neighbors(this);
    for (int i = 0; i < 6; i++) {

    }
}

int OctNode::get_mc_idx() {

    int x[8] = {0, 1, 3, 2, 4, 5, 7, 6};
    int re = 0;
    for (int i = 0; i < 8; i++) {
        if (corner_signs[x[i]] & 1) {
            re |= (1 << i);
        }
    }
    return re;
}




